import gym
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

from gym import spaces
from gym.utils import seeding


class DogNavigation2D(gym.Env):
    """2D navigation problems, as described in [1]. The code is adapted from
    https://github.com/cbfinn/maml_rl/blob/9c8e2ebd741cb0c7b8bf2d040c4caeeb8e06cc95/maml_examples/point_env_randgoal.py

    At each time step, the 2D agent takes an action (its velocity, clipped in
    [-0.1, 0.1]), and receives a rewards which is the inverse of
    its L2 distance to the goal when it is close to the goal position.
    (ie. the reward is `1/distance`). The 2D navigation tasks are
    generated by sampling goal positions from the uniform distribution
    on [-0.5, 0.5]^2.

    [1] Chelsea Finn, Pieter Abbeel, Sergey Levine, "Model-Agnostic
        Meta-Learning for Fast Adaptation of Deep Networks", 2017
        (https://arxiv.org/abs/1703.03400)
    """
    def __init__(self, task={}, low=-0.5, high=0.5, sparse=True):
        super(DogNavigation2D, self).__init__()
        self.low = low
        self.high = high

        self.observation_space = spaces.Box(low=0, high=10,
            shape=(3,), dtype=np.float32)
        self.action_space = spaces.Box(low=-0.1, high=0.1,
            shape=(2,), dtype=np.float32)

        self._task = task
        self.sparse = sparse
        self._goal = task.get('goal', np.zeros(2, dtype=np.float32))
        self._state = np.zeros(2, dtype=np.float32)
        self.seed()



        # Create figure and axes
        def rgb2gray(rgb):
            return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])

        img = mpimg.imread('dog_house.png')
        gray = np.flipud(rgb2gray(img))

        self.map = gray

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def sample_tasks(self, num_tasks):
        goals = []
        # goals.append(np.array([25, 45])/10)
        goals.append(np.array([20, 90])/10)
        goals.append(np.array([53, 40])/10)
        # goals.append(np.array([85, 85])/10)
        goals.append(np.array([85, 13])/10)
        tasks = [{'goal': goal} for goal in goals]
        return tasks

    def sample_test_tasks(self, num_tasks):
        goals = []
        # goals.append(np.array([25, 45])/10)
        goals.append(np.array([20, 90])/10) # seed 25
        # goals.append(np.array([53, 40])/10)
        # goals.append(np.array([85, 85])/10)
        goals.append(np.array([85, 13])/10) # seeds 10 - 30
        tasks = [{'goal': goal} for goal in goals]
        return tasks


    def reset_task(self, task):
        self._task = task
        self._goal = task['goal']

    def reset(self, env=True):
        self._state = np.array([13., 20., 0.])/10
        return self._state

    def step(self, action):
        reward = + 0.
        action = np.clip(action, -0.1, 0.1)

        assert self.action_space.contains(action)

        discrete_state = list(np.rint((self._state[:2] + action)*10))
        pos_y = int(discrete_state[0])
        pos_x = int(discrete_state[1])
        neighbourhood = self.map[pos_x-1:pos_x+2,pos_y-1:pos_y+2]
        if not (np.array(neighbourhood.shape) == 0).any():
            if (neighbourhood > 0.9).all():
                    self._state[:2] = self._state[:2] + action
                    self._state[2] = 0.
            else:
                self._state[2] = 1.
        else:
            self._state[2] = 1.
            # self._state = self._state + action

        x = self._state[0] - self._goal[0]
        y = self._state[1] - self._goal[1]
        distance = np.sqrt(x ** 2 + y ** 2)

        if self.sparse:
            if distance < 0.5: #(np.abs(x) < 1.) and (np.abs(y) < 1.):
                reward = + 1.    # / (distance + 1e-8)
                success = True
            else:
                success = False
            info = {'task': self._task, 'success': float(success)}
        else:
            reward = -distance
            if distance < 0.5: #(np.abs(x) < 1.) and (np.abs(y) < 1.):
                success = True
            else:
                success = False
            info = {'task': self._task, 'success': float(success)}

        done = False    # ((np.abs(x) < 0.05) and (np.abs(y) < 0.05))
        has_end = False

        if has_end and success:
            done = True

        return self._state, reward, done, info